---
layout: post
title: "Java 线程"
category: blog
tags: [Java, Thread]
date: 2019-04-20 08:00:06 +0800
comments: true
hidden: true
---

## 前言
---
最近重读《深入理解 Java 虚拟机》，第一次读是在我刚接触 Java 时，仅凭着对 JVM 的一知半解把这本书大概看了一遍，囫囵吞枣似的，只对 Java 的虚拟机有了简单的认识，相当于在脑海里搭建了虚拟机知识的骨架。之后的工作中，也不断地接触虚拟机相关的知识，虽然不成系统，也向这副"骨架"中填充了不少"血肉"。如今重读，更是想温故而知新，将一些之前没注意到的知识点补全。

当然本文不是一篇读后感，而是对书里某一小节疑问的探究过程，只是觉得有些意思，可能对了解 Java 线程本质有所帮助，所以整理总结一下。

{{ site.article.copyright }}

## 疑问
---
#### 内存溢出
我们知道，JVM 里内存被分为堆区、栈区、方法和常量区以及程序计数器。书中第二章，作者为了将各个区的内存分配策略及其内存泄漏的可能性讲清楚，添加了几个例子，在各区分配大量内存，依次在堆区、方法和常量区制造了人为的内存溢出。

在 JVM 启动参数中限制了 JVM 内存大小后，我们可以很简单地使它们内存溢出：
- 以 `-Xmx20M` 限制最大堆内存大小后，在方法内不停分配无法被回收的对象导致堆区内存溢出。
- 以 `-Xss160K` 限制栈最大内存后，可以通过制造一个死循环递归让栈溢出。

#### 栈区内存溢出
其中使用增加栈最大内存，再通过不停创建线程使栈溢出的方法，让我非常疑惑，开始怀疑作者的试验方法是否正确。

产生疑问的原因有两点：
- 我不相信虚拟机的开发者们会这么"傻"，每次在 JVM 创建线程后，都会给线程预留到最大内存，白白占用宝贵的虚拟机内存，要知道当我们的线程正常运行时，根本用不了这么多的内存。
- Java 的实现是基于操作系统线程的，那么 JVM 给这些线程预留这么多内存如何让操作系统能够用得上呢？
- 最后一点是基于实践，在一次压测时，由于怀疑是线程数太多导致的 CPU 调度繁忙使用 load 高，我曾经将线程数扩充到 9K，而当时 JVM 设置的最大堆内存是 8G，最大线程内存为 1M，内存并没有溢出。

而且书中提及做这个实验时，要小心保存工作区，会导致系统繁忙可能丢失工作区，这一点我也很怀疑，在设置了很小的最大堆内存后，JVM 的变化还能影响到操作系统，可见 JVM 中线程的变化已远远超出了限制。

## 实验
---
Talk is cheap, show me the code. 所以还是自己运行一下最可信。于是找来一台测试机，使用几段 Java 代码实验了一下。

以下代码运行环境是：`Cent OS...`


Xss 不影响最大线程数

ulimit -u

/proc/sys/kernel/pid_max

## 线程和线程池
---

## 小结
---

{{ site.article.summary }}


























