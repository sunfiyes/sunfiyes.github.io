---
layout: post
title: "设计模式，Let's “Go”！ (中)"
date: 2017-08-29 18:00:08 +0800
comments: true
---

<h1 id="toc_0">前言</h1>
<p>接上篇 <a href="./design_pattern_let's_go_1.html">设计模式，Let's &ldquo;Go&rdquo;！ (上)</a>， 继续更新设计模式，今天介绍的设计模式有模板模式、迭代器模式、组合模式、状态模式、代理模式、桥接模式和建造者模式；</p>
<p>文章对设计模式的特点和使用场景进行了总结，每个设计模式分配的篇幅较少，给了解过设计模式的作为速查，帮不了解设计模式的入门， 当然具体实现才是重点，使用现实生活中的事物例子来帮助理解设计模式。</p>
<p>放上 Go 实现设计模式的源码地址：<a href="https://github.com/zhenbianshu/DesignPattern">DesignPattern-枕边书-Github</a> ，偶有更新，欢迎 <code>star</code>。</p>
<p>{{site.article.copyright}}</p>
<hr />
<h1 id="toc_1">模板模式(Template)</h1>
<h3 id="toc_2">介绍</h3>
<p>模板模式：模板模式在<code>抽象类或父类</code>中抽象出<code>算法步骤</code>作为模板，模板的具体细节推迟到子类实现。</p>
<ul>
    <li>模板模式在父类或抽象类中定义一个<code>算法的骨架</code>，并在父类或抽象类中实现共同的部分，各个不同的步骤由不同的子类分别实现；</li>
    <li>模板板式在父类的算法步骤中定义<code>勾子(hook)</code>，在子类中判断并定义一些不是非通用步骤；</li>
    <li>模板模式与策略模式的不同之处在于，策略模式是针对多个不同的算法，而模板模式是针对一个算法的不同步骤，在模板模式中，只有一个算法；</li>
</ul>
<h3 id="toc_3">场景</h3>
<ul>
    <li>多个算法有多个共同之处，但某些步骤略微不同；</li>
    <li>各子类步骤顺序一致，但步骤的具体实现有所不同时；</li>
</ul>
<h3 id="toc_4">实现</h3>
<ol>
    <li>有发邮件和发短信两种通讯方式；</li>
    <li>他们都需要获取目标信息、格式化正文、填写发送方信息，但实现不同；</li>
    <li>在信息类中抽象出三个步骤，具体的处理方式由两种通讯方式各自实现；</li>
    <li>发送信息时调用信息类中的发送方法，发送方法会按照顺序自动调用对应的步骤；</li>
</ol><hr />
<h1 id="toc_5">迭代器模式(Iterator)</h1>
<h3 id="toc_6">介绍</h3>
<p>迭代器模式：迭代器模式允许调用者在<code>不知道类内部实现</code>的情况下<code>遍历类元素</code>。</p>
<ul>
    <li>迭代器接口常用方法有 <code>length(),next(),previous(),remove()</code>等；</li>
    <li>各类在内部实现迭代器接口，用对应的方法操作元素；</li>
    <li>调用者不考虑类内部实现，调用迭代器接口即可；</li>
</ul>
<h3 id="toc_7">场景</h3>
<ul>
    <li>类使用不同的数据结构存储数据；</li>
    <li>需要对不同的数据类型进行遍历等操作；</li>
</ul>
<h3 id="toc_8">实现</h3>
<ol>
    <li>使用 slice 存储一列战马，使用 map 存储一列士兵；</li>
    <li>战马和士兵结构都实现了迭代器接口；</li>
    <li>获取战马数和士兵数，遍历战马和士兵，调用迭代器接口即可；</li>
</ol><hr />
<h1 id="toc_9">组合模式(Composite)</h1>
<h3 id="toc_10">介绍</h3>
<p>组合器模式：使用一种<code>组件抽象</code>来同时表达<code>集合与元素</code>，使用统一的接口来管理集合和元素。</p>
<ul>
    <li>组合模式通常为<code>树结构</code>，父结点和子节点具有同样的抽象和接口；</li>
    <li>在操作集合时，会<code>同时操作集合所属的具体元素</code>；</li>
    <li>通常给组合模式添加一个迭代器来完成组合结构的迭代；</li>
</ul>
<h3 id="toc_11">场景</h3>
<ul>
    <li>管理的多个对象构成树型层级结构；</li>
    <li>操作高层级的对象时，需要同时其所属的下级对象，如界面窗口等；</li>
</ul>
<h3 id="toc_12">实现</h3>
<ol>
    <li>将军、队长、士兵构成树型层级结构，且他们都是战士，拥有战斗方法；</li>
    <li>每位战士都保存着自己的下级名单，没有下级时忽略；</li>
    <li>每个人在战斗时，都会率领着下级战斗；</li>
</ol><hr />
<h1 id="toc_13">状态模式(State)</h1>
<h3 id="toc_14">介绍</h3>
<p>状态模式：状态模式抽象出一个<code>事物的状态</code>作为类，解耦事物和不同状态下的行为；</p>
<ul>
    <li>状态模式通过替换状态对象作为状态转换的方式；</li>
    <li>状态对象实现根据状态动作的接口，可以根据不同的<code>动作做出对应</code>的反应；</li>
    <li>状态模式与策略模式的实现相似，但状态模式是对类内部状态作出改变，而策略模式是针对算法封装；</li>
</ul>
<h3 id="toc_15">场景</h3>
<ul>
    <li>事物有多种状态，且可以相互转换；</li>
    <li>事物多种状态下对同一动作做出的行为不同；</li>
</ul>
<h3 id="toc_16">实现</h3>
<ol>
    <li>植物有 幼苗、开花和成熟 三种状态，且它们会通过浇水和收获的动作进行相互转换；</li>
    <li>幼苗和开花时不能收获，只能浇水，成熟状态只能收获，不需要再浇水；</li>
    <li>定义三种状态，和它们对不同动作时的行为，植物通过三种对象的替换来进行状态转换；</li>
</ol><hr />
<h1 id="toc_17">代理模式(Proxy)</h1>
<h3 id="toc_18">介绍</h3>
<p>代理模式：给对象提供一个代理，由代理对象控制对原对象的调用；</p>
<ul>
    <li>代理模式为一个对象（通常是大对象或无法复制的对象）<code>创建另外一个类作为其访问的接口</code>，所有对真实对象的请求都<code>通过代理对象</code>完成；</li>
    <li>代理对象可以<code>控制用户对真实对象的访问权限</code>，也可以在访问真实对象时附加功能;</li>
    <li>代理模式可被用作：远程代理，虚拟代理，安全代理，指针引用，延迟加载；</li>
</ul>
<h3 id="toc_19">场景</h3>
<ul>
    <li>对象无法被直接访问时；</li>
    <li>对象过大，初始化较慢；</li>
    <li>对象不必要立刻初始化，可使用默认值代替；</li>
</ul>
<h3 id="toc_20">实现</h3>
<ol>
    <li>小明给暗恋对象写了一封信，在等回信；</li>
    <li>邮递员是个非常忙的人，来不及去收取回信；</li>
    <li>小明好声好气向邮递员要回信时，邮递员都推拖说自己要去取；</li>
    <li>小明发怒了，邮递员终于抽时间去取了信给小明；</li>
    <li>此信中邮递员就是代理模式中的代理，他实现了懒加载。</li>
    <li>回信内容见源码：）</li>
</ol><hr />
<h1 id="toc_21">桥接模式(Bridge)</h1>
<h3 id="toc_22">介绍</h3>
<p>桥接模式：将事务的<code>多个维度</code>都抽象出来以<code>解耦抽象与实际</code>之间的绑定关系，使抽象和实际向着不同维度改变；</p>
<ul>
    <li>桥接模式通过对象的组合来解决事物的多维度变化问题，以替代多继承的不灵活；</li>
    <li>桥接模式可以轻易在多维度上拓展，而不改变原有模式；</li>
    <li>桥接模式与策略模式的不同之处：策略模式是针对一个不变的主题替换抽象算法，而桥接模式是策略模式的高维度状态，它的主题也可能会被替换；</li>
</ul>
<h3 id="toc_23">场景</h3>
<ul>
    <li>某事物在多个维度上都有变化；</li>
    <li>无法使用多继承或使用多继承会很不灵活；</li>
</ul>
<h3 id="toc_24">实现</h3>
<ol>
    <li>作画时可以使用铅笔和圆珠笔等不同的笔，也可以在宣纸或普通A4纸；</li>
    <li>抽象出笔和纸两种对象；</li>
    <li>自由组合笔和纸进行作画；</li>
</ol><hr />
<h1 id="toc_25">建造者模式(Builder)</h1>
<h3 id="toc_26">介绍</h3>
<p>建造者模式：建造者模式<code>分离创建复杂对象的过程和细节</code>，使得同样的创建过程能创建不同的对象。</p>
<ul>
    <li>建造者模式将创建对象部件的<code>一般过程抽象出接口</code>，而由不同的建造者类实现具体的接口，实现过程的步骤；</li>
    <li>通过建造者，调用者不用考虑对象创建过程的细节，且建造者也可以被灵活替换；</li>
    <li>与模板模式的区别：建造者模式使用类的组合进行对象的创建，而模板模式使用类的继承实现对象的具体构造；</li>
    <li>与工厂模式的区别：工厂模式会返回一个具体类，而建造者模式会建造出一个由多个类组装而成的完整类；</li>
</ul>
<h3 id="toc_27">场景</h3>
<ul>
    <li>对象的创建包含其他对象为类元素，创建过程复杂；</li>
    <li>多个复杂对象的创建过程具有高度相似性；</li>
</ul>
<h3 id="toc_28">实现</h3>
<ol>
    <li>中国式建筑有金色屋顶和红色大门，而意式建筑有圆项和白色大门；</li>
    <li>中国建筑师和意式建筑师分别擅长建造不同类型的建筑；</li>
    <li>我们在盖不同类型的房子时先创建一个建筑师，再用建筑师去创建对应风格的房子；</li>
</ol><hr />
<h1 id="toc_29">小结</h1>
<p>开发者对设计模式常陷入两个误区，要么极度推崇，要么弃如弊履。 极度推崇的人认为设计模式就是圣经，是程序设计的最高实现，以至于写代码时就往设计模式上凑，最终写出的代码冗余沉重，让人很难懂；而鄙弃设计模式的人实用至上，认为写出的代码能实现业务功能就好，对设计模式理也不理，结果代码杂乱不堪，稍有改动就引出一大堆 BUG，跟别人解释实现时，别人听得云里雾里。</p>
<p>我认为设计模式就是一些定义，就像冒泡排序、快速排序这些名字一样，便于开发者之间的交流，特别是在代码中，如果你提到使用了XX模式，如果阅读你代码的人也了解这个设计模式，那么他了解你的实现也就更加简单了。像之前在不了解设计模式的概念时，我就已经在很多地方应用模板模式和策略模式了，但在向别人介绍代码实现时，我需要说一堆代码设计，别人还不一定能理解，如果以后再跟人交流时，我不需要解释很多，只说我实现了模板模式就OK了。而且学会并深入了解了设计模式，那么以后遇到适用设计模式的场景，就可以不用苦逼地一遍遍修改代码，而直接朝着最美的方向设计了。</p>
<p>所以深入学习设计模式也是学习程序设计中很多问题的普遍解决方式，也是学习程序员之前交流的专业词汇，意义还是挺重大的。</p>
<p>关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 <strong>推荐</strong> 支持一下我。博客一直在更新，欢迎 <strong>关注</strong> 。</p>