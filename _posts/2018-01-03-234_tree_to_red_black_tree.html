---
layout: post
title: "通过2-3-4树理解红黑树"
date: 2018-01-03 18:00:06 +0800
comments: true
---

<h1>前言</h1>
<p>红黑树是数据结构中比较复杂的一种，最近与它交集颇多，于是花了一周的空闲时间跟它死磕，终于弄明白并实现了红黑树。写文总结一下，希望能给试图理解红黑树的同学一些灵感，也让我能记得更深刻。</p>
<p>在研究红黑树时吃了不少苦头，原因有二：</p>
<ul>
    <li>红黑树的插入和删除非常复杂，很多人并没有理解或完全实现，或实现了的没有任何注释，让人很难参考；</li>
    <li>网络上红黑树的理解方式较为单一，一般是 <code>双黑、caseN</code> 法，而插入和删除的情况很多，每种都有对应的处理方式，如果死记硬背的话，再过一段时间再回忆各种情况可能就一头雾水了。</li>
</ul>
<p>网络上讲红黑树的实现多来源于《算法导论》一书，直接讲红黑树的实现，需要处理颜色和高度两种属性约束，比较晦涩。本文通过红黑树的等同&mdash;&mdash; 2-3-4树，避开颜色属性约束，也弱化了高度的影响，以另一种方式去理解红黑树，虽然并不能完全降低它的复杂度，但自认为较之普遍实现，更易记一些。</p>
<p>文章最前面先放上红黑树的实现源码，代码在 Github 上，一开始实现时使用我最熟练的 PHP，后续添加了 Java 版，代码都可以直接运行。源码链接：<a href="https://github.com/zhenbianshu/DataStructureAndAlgorithm"><strong><code>GitHub-枕边书-RBTree</code></strong></a>，欢迎<code>star</code>。</p>
<p>{{site.article.copyright}}</p>
<hr />
<h1 id="toc_1">红黑树</h1>
<h3 id="toc_2">定义</h3>
<p>红黑树是一种结点带有颜色属性的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树</a>，但它在二叉查找树之外，还有以下要求：</p>
<ol>
    <li>节点是红色或黑色。</li>
    <li>根是黑色。</li>
    <li>所有叶子都是黑色（叶子是NIL节点）。</li>
    <li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
    <li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>下图就是一个典型的红黑树：</p>
<h3 id="toc_3"><img src="/images/2018/819496-20180103193521440-1612942831.png" alt="" /></h3>
<p>但实现上我省略了其中的 Nil 结点，一般如下图，大家理解时也可以忽略它们。</p>
<h3 id="toc_4"><img src="/images/2018/819496-20180103193539737-260894910.png" alt="" /></h3>
<h3 id="toc_5">优势和用途</h3>
<p>我们知道二叉查找树在不停地添加或删除结点后，可能会导致结点情况如下：</p>
<h3 id="toc_6"><img src="/images/2018/819496-20180103193551440-1435476180.png" alt="" /></h3>
<p>这种情况下，二叉查找树的查找效率最坏会降低为 <code>O(n)</code>。</p>
<p>而红黑树由于在插入和删除结点时都会进行变色旋转等操作，在符合红黑树条件的情况下，即使一边子树全是黑色结点，另一边子树全是红黑相间，两子树的高度差也不会超过一半。一棵有 n 个结点的红黑树高度至多为 <code>2log(n+1)</code>，查找效率最坏为 <code>O(log(n))</code>。</p>
<p>所以红黑树常被用于需求查找效率稳定的场景，如 Linux 中内核使用它管理内存区域对象、Java8 中 HashMap 的实现等，所以了解红黑树也很有意义。</p>
<p>下面介绍一下红黑树的等同 2-3-4树。</p>
<hr />
<h1 id="toc_7">2-3-4树</h1>
<h3 id="toc_8">定义</h3>
<p>2-3-4树是四阶的 B树(Balance Tree)，它的结构有以下限制：</p>
<ul>
    <li>所有叶子节点都拥有相同的深度。</li>
    <li>
        <p>节点只能是 2-节点、3-节点、4-节点之一。</p>
        <ul>
            <li>2-节点：包含 1 个元素的节点，有 2 个子节点；</li>
            <li>3-节点：包含 2 个元素的节点，有 3 个子节点；</li>
            <li>4-节点：包含 3 个元素的节点，有 4 个子节点；</li>
        </ul>
    </li>
    <li>
        <p>元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点；而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。</p>
    </li>
</ul>
<p>下图是一个典型的 2-3-4树（来自维基百科）：</p>
<h3 id="toc_9"><img src="/images/2018/819496-20180103193607612-403302618.png" alt="" /></h3>
<p>2-3-4树的查询操作像普通的二叉搜索树一样，非常简单，但由于其结点元素数不确定，在一些编程语言中实现起来并不方便，实现一般使用它的等同&mdash;&mdash;红黑树。</p>
<h3 id="toc_10">对应红黑树</h3>
<p>至于为什么说红黑树是 2-3-4树的一种等同呢，这是因为 2-3-4树的每一个结点都对应红黑树的一种结构，所以每一棵 2-3-4树也都对应一棵红黑树，下图是 2-3-4树不同结点与红黑树子树的对应。</p>
<h3 id="toc_11"><img src="/images/2018/819496-20180103193633831-1494601217.png" alt="" /></h3>
<p>而上文中的 2-3-4树也可以转换成一棵红黑树：</p>
<h3 id="toc_12"><img src="/images/2018/819496-20180103193647346-2000126888.png" alt="" /></h3>
<p>由红黑树的性质5，和 2-3-4树的性质1，为了便于理解红黑树和 2-3-4树的对应关系，我们可以<code>把红黑树从根结点到叶子结点的黑色结点个数定义为高度</code>。</p>
<p>红黑树和 2-3-4树的结点添加和删除都有一个基本规则：避免子树高度变化，因为无论是 2-3-4树还是红黑树，一旦子树高度有变动，势必会影响其他子树进行调整，所以我们在插入和删除结点时尽量通过子树内部调整来达到平衡，2-3-4树实现平衡是通过结点的旋转和结点元素数变化，红黑树是通过结点旋转和变色。</p>
<p>下面来对照着 2-3-4树说一下红黑树结点的添加和删除：</p>
<hr />
<h1 id="toc_13">结点插入</h1>
<p>2-3-4树中结点添加需要遵守以下规则：</p>
<ul>
    <li>插入都是向最下面一层插入；</li>
    <li>升元：将插入结点由 2-结点升级成 3-结点，或由 3-结点升级成 4-结点；</li>
    <li>向 4-结点插入元素后，需要将中间元素提到父结点升元，原结点变成两个 2-结点，再把元素插入 2-结点中，如果父结点也是 4-结点，则递归向上层升元，至到根结点后将树高加1；</li>
</ul>
<p>而将这些规则对应到红黑树里，就是：</p>
<ul>
    <li>新插入的结点颜色为<code>红色</code>，这样才可能不会对红黑树的高度产生影响。</li>
    <li>2-结点对应红黑树中的单个黑色结点，插入时直接成功（对应 2-结点升元）。</li>
    <li>3-结点对应红黑树中的<code>黑+红</code>子树，插入后将其修复成 <code>红+黑+红</code> 子树（对应 3-结点升元）；</li>
    <li>4-结点对应红黑树中的<code>红+黑+红</code>子树，插入后将其修复成<code>红色祖父+黑色父叔+红色孩子</code>子树，然后再把祖父结点当成新插入的红色结点递归向上层修复，直至修复成功或遇到 root 结点；</li>
</ul>
<h3 id="toc_14"><img src="/images/2018/819496-20180103193702643-1375531970.png" alt="" /></h3>
<p>如上图所示，虽然向红黑树中插入了一个新结点，但由于旋转和变色，子树的高度保持不变。</p>
<hr />
<h1 id="toc_15">删除结点</h1>
<p>红黑树的删除要比插入要复杂一些，我们还是类比 2-3-4树来讲：</p>
<ul>
    <li>查找最近的叶子结点中的元素替代被删除元素，删除替代元素后，从替代元素所处叶子结点开始处理；</li>
    <li>降元：4-结点变 3-结点，3-结点变 2-结点；</li>
    <li>2-结点中只有一个元素，所以借兄弟结点中的元素来补充删除后的造成的空结点；</li>
    <li>当兄弟结点中也没有多个元素可以补充时，尝试将父结点降元，失败时向上递归，至到子树降元成功或到 root 结点树高减1；</li>
</ul>
<p>将这些规则对应到红黑树中即：</p>
<ul>
    <li>查找离当前结点最近的叶子结点作为<code>替代结点</code>（左子树的最右结点或右子树的最左结点都能保证替换后保证二叉查找树的结点的排序性质，叶子结点的替代结点是自身）替换掉被删除结点，从替代的叶子结点向上递归修复；</li>
    <li>替代结点颜色为红色（对应 2-3-4树中 4-结点或 3-结点）时删除子结点直接成功；</li>
    <li>
        <p>替代结点为黑色（对应 2-3-4树中 2-结点）时，意味着替代结点所在的子树会降一层，需要依次检验以下三项，以恢复子树高度：</p>
        <ul>
            <li>兄弟结点的子结点中有红色结点（兄弟结点对应 3-结点或 4-结点）能够&ldquo;借用&rdquo;，旋转过来后修正颜色；</li>
            <li>父结点是红色结点（父结点对应 3-结点或 4-结点，可以降元）时，将父结点变黑色，自身和兄弟结点变红色后删除；</li>
            <li>父结点和兄弟结点都是黑色时，将子树降一层后把<code>父结点当作替代结点</code>递归向上处理。</li>
        </ul>
    </li>
</ul>
<h3 id="toc_16"><img src="/images/2018/819496-20180103193715581-889626605.png" alt="" /></h3>
<p>如上图，删除的要点是 <code>找到替代结点</code>，如果替代结点是黑色，递归向上依次判断侄子结点、父结点是否可以补充被删除的黑色，整体思想就是将删除一个黑色结点造成的影响局限在子树内处理。</p>
<hr />
<h1 id="toc_17">小结</h1>
<p>当然实现过程中调试也占了很大一部分，我使用了两项方法帮助调试：</p>
<ul>
    <li>由于插入多个结点时，无法确定是处理哪个结点时出了问题，于是我给红黑树类添加了 <code>debug</code> 属性，用二分法设置此属性来找到问题结点；</li>
    <li>给红黑树类添加了 <code>printTree()</code> 方法，实时打印树结构，确定代码问题再分析；</li>
</ul>
<p>由于红黑树相对其他树实在较为复杂，只通过思考就完全理解不太现实，还需要自己去试着画，试着实现，我画了 5 张 A4 纸的正反面才算理解了红黑树，即便如此，在写这篇文章时还发现了代码中的可优化点。</p>
<p>而且代码实现比画图还略复杂，理论中的一个<code>旋转</code>就包含了 <code>左旋/右旋/先左旋再右旋/先右旋再左旋</code> 几种情况，虽然有一定规律，还是自己实现一下印象最深刻。</p>
<p>{{site.article.summary}}</p>