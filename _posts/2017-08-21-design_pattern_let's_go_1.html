---
layout: post
title: "设计模式，Let's “Go”！ (上)"
date: 2017-08-21 18:00:08 +0800
comments: true
---

<h1 id="toc_0">前言</h1>
<p>最近读了《Head First 设计模式》，每天早上看一章，学习一个设计模式，做些笔记，然后晚上抽空用刚学习的 Go 语言实现一下。半个月下来书读完了，留下了一些笔记，写博客总结一下。</p>
<p>书中的例子都是 Java 写的，但几乎没使用 Java 语言的特性，很容易看懂。对于我来说，就是一个 PHP 开发工程师，读了一本 用 Java 语言实现设计模式的书，然后用 Go 写了一遍。。。=_=</p>
<p>本文为每个设计模式只分配了一小节，总结一下设计模式的概念和特点以及适用场景，并介绍了自己用代码实现时的列举的例子，用现实生活中的事物对比加深一下记忆 （ 代码实现中所有的例子都是自己原创的，有牵强的部分，不要介意）。每个模式篇幅不大，可以给新人入门，给了解过设计模式的人作为速查。</p>
<p>{{site.article.copyright}}</p>
<p>放上 Go 实现设计模式的 源码地址：<a href="https://github.com/zhenbianshu/DesignPattern">DesignPattern-枕边书-Github</a> ，偶有更新，欢迎 <code>star</code>。OK，正文开始。</p>
<hr />
<h1 id="toc_1">策略模式(Strategy)</h1>
<h3 id="toc_2">介绍</h3>
<p>策略模式： 将算法或操作抽象成<code>实现共同接口、可以被替换</code>的类，实现逻辑和具体算法的解耦。</p>
<ul>
    <li>将各种行为<code>抽象成算法</code>，封装算法为对象；</li>
    <li>算法实现<code>共同接口</code>，调用者调用时不考虑算法具体实现，调用接口方法即可；</li>
    <li>调用者可随时替换此算法对象；</li>
</ul>
<h3 id="toc_3">场景</h3>
<ul>
    <li>多个方法择一使用，且他们会被随时替换；</li>
    <li>方法没有共性，使用继承会有大量重写，使用接口会有大量重复使用；</li>
</ul>
<h3 id="toc_4">实现</h3>
<ol>
    <li>两个算法： 冒泡排序和快速排序；</li>
    <li>抽象冒泡排序和快速排序为算法对象，实现算法接口，拥有 used() 被使用方法；</li>
    <li>计算器计算时不用理会是什么算法，调用 used() 即可；</li>
</ol><hr />
<h1 id="toc_5">观察者模式(Observer)</h1>
<h3 id="toc_6">介绍</h3>
<p>观察者模式：主题<code>主动向观察者推送</code>变化，解决观察者对主题对象的依赖。</p>
<ul>
    <li>观察者实现<code>被通知</code>接口，并在主题上注册，主题只<code>保存观察者的引用</code>，不关心观察者的实现；</li>
    <li>在主题有变化时调用观察者的通知接口来通知已注册的观察者；</li>
    <li>通知方式有<code>推</code>（主题变化时将变化数据推送给观察者）和<code>拉</code>（主题只告知变化，观察者主动来拉取数据）；</li>
</ul>
<h3 id="toc_7">场景</h3>
<ul>
    <li>一个主题，多个观察者，主题的任何变动，观察者都要第一时刻得到；</li>
    <li>观察者获取主题变化困难，定时不及时，轮询消耗大；</li>
    <li>观察者可以随时停止关注某主题；</li>
</ul>
<h3 id="toc_8">实现</h3>
<ol>
    <li>张三和李四是记者，他们需要及时了解城市发生的新闻；</li>
    <li>张三和李四在电视台注册了自己的信息；</li>
    <li>城市发生了新闻，电视台遍历注册信息，通知了张三和李四；</li>
    <li>李四退休了，在电视台注销了自己的信息；</li>
    <li>城市又发生了新闻，电视台只通知了张三；</li>
</ol><hr />
<h1 id="toc_9">装饰者模式(Decorator)</h1>
<h3 id="toc_10">介绍</h3>
<p>装饰者模式：包装一个对象，在被装饰对象的基础上<code>添加功能</code>；</p>
<ul>
    <li>装饰者与被装饰对象拥有同一个超类，<code>装饰者拥有被装饰对象的所有外部接口</code>，可被调用，外界无法感知调用的是装饰者还是被装饰者；</li>
    <li>装饰者需要被装饰者作为参数传入，并在装饰者内部，在<code>被装饰者实现的基础上添加或修改某些功能</code>后，提供同被装饰者一样的接口；</li>
    <li>装饰者也可被另一个装饰者装饰，即嵌套装饰；</li>
    <li>装饰者是一群包装类，由于装饰的复杂性，会多出很多个装饰者小类；</li>
</ul>
<h3 id="toc_11">场景</h3>
<ul>
    <li>对象需要动态地添加和修改功能；</li>
    <li>功能改变后不影响原对象的使用；</li>
</ul>
<h3 id="toc_12">实现</h3>
<ol>
    <li>在商店内，花作为被装饰者对象、红丝带和盒子作为花的装饰者；</li>
    <li>花、红丝带、盒子有共同的超类&ldquo;商品&rdquo;，他们都能被卖掉；</li>
    <li>我们可以在红丝带装饰过花后，再用盒子再包装一次；</li>
    <li>包装后的花，顾客买时也不会受到任何影响；</li>
</ol><hr />
<h1 id="toc_13">工厂模式(Factory)</h1>
<h3 id="toc_14">介绍</h3>
<p>工厂模式： 顾名思义，工厂模式是<code>对象的生产器</code>，解耦用户对具体对象的依赖。</p>
<ul>
    <li>实现<code>依赖倒置</code>，让用户通过一个<q>产品工厂</q><code>依赖产品的抽象</code>，而不是一个具体的产品；</li>
    <li>简单工厂模式：接收参数并根据参数创建对应类，将对象的实例化和具体使用解耦；</li>
    <li>抽象工厂模式：将工厂<code>抽象出多个生产接口</code>，不同类型的工厂调用生产接口时，生产不同类型的对象；</li>
    <li>简单工厂常配合抽象工厂一起使用；</li>
</ul>
<h3 id="toc_15">场景</h3>
<ul>
    <li>根据不同条件需求不同的对象；</li>
    <li>对象实例化的代码经常需要修改；</li>
</ul>
<h3 id="toc_16">实现</h3>
<ol>
    <li>简单工厂：向鞋厂内传入不同的类型（布制），鞋厂会生产出不同类型的鞋子（布鞋）；</li>
    <li>抽象工厂：有两座鞋厂：李宁鞋厂、Adidas鞋厂，他们能生产对应各自品牌的鞋子；</li>
    <li>搭配使用：向不同的抽象工厂（李宁）传入不同的类型（运动类型），会生产出对应品牌对应类型的鞋子（李宁运动鞋）；</li>
</ol><hr />
<h1 id="toc_17">单例模式(Singleton)</h1>
<h3 id="toc_18">介绍</h3>
<p>单例模式：保证同一个类<code>全局只有一个实例对象</code>;</p>
<ul>
    <li>在第一次实例化后会使用<code>静态变量保存</code>实例，后续全局使用此静态变量；</li>
    <li>一般将构造方法私有化，构造方法添加 final 关键字无法被重写，添加一个类静态方法用于返回此实例；</li>
    <li>在多线程时应该考虑<code>并发</code>问题，防止两次调用都被判定为实例未初始化而重复初始化对象；</li>
</ul>
<h3 id="toc_19">场景</h3>
<ul>
    <li>全局共享同一个实例对象（数据库连接等）；</li>
    <li>某一处对此对象的更新全局可见；</li>
</ul>
<h3 id="toc_20">实现</h3>
<ol>
    <li>利用 Go 中包的可见性规则来隐藏对象的实例化权限；</li>
    <li>使用包变量保存实例对象，获取实例时判断是否已实例化，如为nil，实例化对象并返回，如有值，直接返回值；</li>
    <li>待用锁实现 Go routine 并发时的问题；</li>
</ol><hr />
<h1 id="toc_21">命令模式(Command)</h1>
<h3 id="toc_22">介绍</h3>
<p>命令模式:将一个<code>命令封装成对象</code>，解耦命令的发起者和执行者。</p>
<ul>
    <li>命令对象实现<code>命令接口（excute[、undo]）</code>，命令发起者实例化命令对象，并传递此对象，并不关心此对象由谁执行；</li>
    <li>命令执行者只负责调用命令对象的执行方法即可，不关心对象是由谁生成的；</li>
    <li>与策略模式不同之处：策略模式是通过不同的算法做同一件事情（例如排序），而命令模式则是通过不同的命令做不同的事情；</li>
</ul>
<h3 id="toc_23">场景</h3>
<ul>
    <li>命令发起者与执行者无法直接接触；</li>
    <li>命令需要撤销功能，却不易保存命令执行状态信息时；</li>
</ul>
<h3 id="toc_24">实现</h3>
<ol>
    <li>指挥官创建了一个&ldquo;从树下跑到草地上&rdquo;的命令；</li>
    <li>命令被分配给张三执行，张三作为军人，接到命令后不管命令的具体内容，而是直接调用命令的执行接口执行；</li>
    <li>指挥官发布了撤销指令，张三又从草地上跑到了树下；</li>
</ol><hr />
<h1 id="toc_25">适配器模式(Adapter)</h1>
<h3 id="toc_26">介绍</h3>
<p>适配器模式：包装对象提供一个接口，以<code>适配调用者</code>。</p>
<ul>
    <li>适配器通过一个中间对象，<code>封装目标接口</code>以<code>适应调用者</code>调用；</li>
    <li>调用者调用此适配器，以达到调用目标接口的目的；</li>
    <li>适配器模式与装饰者模式的不同之处：适配器模式不改变接口的功能，而装饰者会添加或修改原接口功能；</li>
</ul>
<h3 id="toc_27">场景</h3>
<ul>
    <li>提供的接口与调用者调用的其他的接口都不一致；</li>
    <li>为一个特殊接口修改调用者的调用方式得不偿失；</li>
</ul>
<h3 id="toc_28">实现</h3>
<ol>
    <li>张三是个正常人，他能通过说话直接地表达自己；</li>
    <li>李四是个聋哑人，他没法直接表达自己，但他会写字；</li>
    <li>笔记本作为一个适配器，用笔记本&ldquo;包装&rdquo;了李四之后，当李四需要表达自己想法时，调用笔记本的&ldquo;表达&rdquo;功能，笔记本再调用李四&ldquo;写字&rdquo;的方法；</li>
</ol><hr />
<h1 id="toc_29">外观模式(Facade)</h1>
<h3 id="toc_30">介绍</h3>
<p>外观模式：通过<code>封装多个复杂的接口</code>来提供一个<code>简化接口</code>来实现一个复杂功能。</p>
<ul>
    <li>外观模式是通过封装多个接口来将接口<code>简单化</code>；</li>
    <li>外观模式不会改变原有的多个复杂的单一接口，这些接口依然能被单独调用，只是提供了一个额外的接口；</li>
    <li>外观模式与适配器模式的不同之处：外观模式是<code>整合</code>多个接口并<code>添加</code>一个简化接口，适配器是适配一个接口；</li>
</ul>
<h3 id="toc_31">场景</h3>
<ul>
    <li>实现某一功能需要调用多个复杂接口；</li>
    <li>经常需要实现此功能；</li>
</ul>
<h3 id="toc_32">实现</h3>
<ol>
    <li>正常的冲咖啡步骤是：磨咖啡豆、烧开水、倒开水搅拌咖啡。</li>
    <li>我们经常需要直接冲咖啡，而不是使用单一步骤，每次喝咖啡时调用三个方法很麻烦；</li>
    <li>封装三个接口，额外提供一个 &ldquo;冲咖啡&rdquo; 的方法，需要喝咖啡时只需要调用一次冲咖啡方法即可；</li>
</ol><hr />
<h1 id="toc_33">小结</h1>
<p>《Head First 设计模式》这书真心不错，例子很轻松，给人很多时间和空间来思考，同时介绍模式时使用结合故事，层层深入的方法，让人印象很深刻，推荐。</p>
<p>书中详细介绍了 14 个基础设计模式，还有 9 个简化版，就自己查资料结合自己的理解来总结了。</p>
<p>本系统准备写三篇，敬请期待中下篇。</p>
<p>关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 <strong>推荐</strong> 支持一下我。博客一直在更新，欢迎 <strong>关注</strong> 。</p>